# 4. 이벤트 핸들링

이 템플릿으로 엔니어링 부서의 모든 팀원을 위한 지침서를 만들어 보세요. 목차를 추가하려면 `/목차`를 입력하고 `enter` 키를 누르면 됩니다.

# 이벤트란?

 

- 사용자가 웹 브라우저에서 DOM 요소들과 상호 작용하는것

# 1. 리액트의 이벤트 시스템

- 웹 브라우저의 HTML 이벤트와 인터페이스 동일(사용법 비슷)

## 1.1. 이벤트를 사용할 때 주의사항

- 이벤트 이름은 카멜 표기법으로 작성
- 이벤트에 실행할 JavaScript 코드 전달 X → 함수 형태의 값 전달
- DOM 요소에만 이벤트 설정 가능
    - 직접 만든 컴포넌트에는 이벤트 자체적으로 설정 불가

# 2. 이벤트 핸들링 익히기

## 2.1. onChnage 이벤트 핸들링 하기

```jsx
<div>
     <h1>이벤트 연습</h1>
     <input
     type="text"
     name="message"
     placeholder="아무거나 입력해 보세요"
     onChange={
         (e) => {
             console.log(e);
         }
				 {/*함수 형태의 값 전달*/}
     }
     />
 </div>
```

- 'e' : 이벤트 객체(Synthetic Event)
    - 웹 브라우저의 '네이티브 이벤트'(인터페이스)를 감싸는 객체
    - 순수 자바스크립트에서 HTML 이벤트를 다룰 때와 똑같이 사용
    - '네이티브 이벤트'(인터페이스)와 달리 이벤트가 끝나고 나면 이벤트가 초기화 됨으로 정보 참조 불가능
        - 0.5초 뒤에 'e' 객체 참조 시 'e' 객체 내부의 모든 값이 비워지게 됨
        - 비동기적으로 이벤트 객체 참조할 일 있다면 ` e.persist()` 함수 호출해야 됨
        - ex) onChange() 이벤트 발생 > 앞으로 변할 인풋 값인 e.target.value를 콘솔에 기록

            ```jsx
            onChange={
                 (e) => {
                     console.log(e.target.value);//앞으로 변할 인풋 값 기록
                 }
             }
            ```

## 2.2. State에 input 값 담기 (setState)

```jsx

<div>
     <h1>이벤트 연습</h1>
     <input
     type="text"
     name="message"
     placeholder="아무거나 입력해 보세요"
     value={this.state.message}
     onChange={
         (e) => {
             this.setState({
                 message : e.target.value
             })
						{/*e 객테의 값을 state값으로 설정*/}
             console.log(e.target.value);
         }
     }
     />
 </div>
```

## 2.3. 버튼 누를 때 comment 값을 공백으로 설정

```jsx
<div>
     <h1>이벤트 연습</h1>
     <input
     type="text"
     name="message"
     placeholder="아무거나 입력해 보세요"
     value={this.state.message}
     onChange={
         (e) => {
             this.setState({
                 message : e.target.value
             });
             console.log(e.target.value);
         }
     }
     />
     <button onClick={
         () => {
             alert(this.state.message);
             this.setState({
                 message : ''
             });
						{/*버튼 누를 때마다 state 값 초기화*/}
         }
     }>
     확인
     </button>
 </div>
```

## 2.4. 임의 메서드 만들기

- 이벤트를 처리할 때 렌더링 하는 동시에 함수를 만들어 전달 가능(함수 미리 준비해 전달)
- 두 방법 성능상으로 차이 거의 없지만 가독성은 임의 메서드가 더 높음

```jsx
state = {
       message : ''
   }
   constructor(props){
       super(props);
       this.handleChange = this.handleChange.bind(this);
       this.handleClick = this.handleClick.bind(this);
   }
 
	//임의 메서드 생성
   handleChange(e){
       this.setState({
           message : e.target.value
       });
       console.log(e.target.value);
   }
 
   handleClick(e){
       alert(this.state.message);
       this.setState({
           message : ''
       });
   }
   render(){
       return(
           <div>
               <h1>이벤트 연습</h1>
               <input
               type="text"
               name="message"
               placeholder="아무거나 입력해 보세요"
               value={this.state.message} 
               onChange={this.handleChange}{/*임의 메서드 호출(호출과 동시에 생성)*/}
               />
               <button onClick={this.handleClick}>
               확인
               </button>
           </div>
       );
   }
```

- 함수가 호출될때 this는 호출부에 따라 결정됨
    - 클래스의 임의 메서드가 특정 HTML 요소와 이벤트로 등록되는 과정에서 메서드와 this의 관계가 끊어져 버림
    - 메서드가 이벤트로 등록되어도 this를 컴포넌트 자신으로 가르키기 위해 메서드 this 와 바인딩(binding)하는 작업 필요
    - > 바인딩 하지 않은 경우라면 this가 undefined를 가르키게 된다
- Property Initializer Syntax를 사용한 메서드 작성
    - 메서드 바인딩은 생성자 메서드에서 하는 것 정석
        - 새 메서드 만들 때마다 constructor 수정해야 됨
    - 생성자 메서드에서 하는 단점 커버 위해
    - 바벨의 transform-class-properties 문법 사용해 화살표 함수 형태로 메서드 정의!

## 2.5. input 여러 개 다루기

- event 객체를 활용해 name 을 사용
- 이렇게 사면 DOM 객체의 name 값에 value를 넣을 수 있다.
- 객체 안에서 key 를 로 감싸면 그 안에 넣은 레퍼런스가 가르키는 실제 값이 key 값으로 사용 된다

```jsx
handleChange = (e) => {
   this.setState({
      //message : e.target.value
       [e.tartget.name] : e.target.value
   });
}
```

## 2.6. onKeyPress 이벤트 핸들링

```jsx
handleKeyPress = (e) => {
       if(e.key === 'Enter'){
           this.handleClick();
       }
   }
```

# 3. 함수형 컴포넌트로 구현

```jsx
import React, { useState } from 'react';
 
const EventPracties = () => {
  
   const[form, setForm] = useState({
       username : '',
       message : ''
   });
 
   const {username, message} = form;
 
   const onChange = e => {
       const nextForm = {
           ...form,
           [e.target.name] : e.target.value
       };
       setForm(nextForm);
   };
   //const onChangeUsername = e => setUsername(e.target.value);
   //const onChangeMessage = e => setMessage(e.target.value);
   const onClick = () => {
       alert(username + ' : ' + message);
       setForm({
           username : '',
           message : ''
       });
       //setMessage('');
       //setUsername('');
   };
 
   const onKeyPress = e => {
       if(e.key === 'Enter'){
           onClick();
       }
   };
 
   return(
       <div>
           <h1>이벤트 연습</h1>
           <input
           type="text"
           name="username"
           placeholder="사용자명"
           value={username}
           onChange={onChange}
           />
           <input
           type="text"
           name="message"
           placeholder="아무거나 입력해 보세요"
           value={message}
           onChange={onChange}
           onKeyPress={onKeyPress}
           />
           <button onClick={onClick}>
               확인
           </button>
       </div>
   );
}
 
export default EventPracties;
```

# 4. 정리

순수 자바스크립트 또는 jQuery 와 HTML DOM Event 처리 방식 비슷