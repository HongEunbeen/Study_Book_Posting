# 9장 단위 테스트

이전까지의 테스트는 클래스와 메서드를 공들여 구현한 후 임시 코드를 급조해 테스트를 수행하는 방식

→ 애자일과 TDD 덕택에 단위 테스트를 자동화하는 프로그래머들이 많아지고 있다!!

# TDD 법칙 세 가지

TDD는 실제 코드를 짜기 전에 단위 테스트를 작성해야 한다!

- 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
- 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
- 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.

→ 위 세개의 규칙을 따르면 개발과 테스트가 대략 30초 주기로 묶인다.

실제 코드와 맞먹을 정도로 방대한 테스트 코드는 심각한 관리 문제 유발 가능성 존재!

## 깨끗한 테스트 코드 유지하기

일회용 테스트 코드를 짜오다가 새삼스레 자동화된 단위 테스트 슈트를 짜기란 쉽지 않다.

테스트 코드가 복잡할수록 실제 코드를 짜는 시간보다 테스트 케이스를 추가하는 시간이 더 걸림

→ 실제 코드가 변경되면 테스트 코드도 변경되어야 하는데 케스트 코드 지저분할수록 변경 어려움

테스트 코드는 실제 코드 못지 않게 중요하다!!

## 테스트는 유연성, 유지보수성, 재사용성을 제공한다.

코드에 유연성, 유지보수성, 재사용성을 제공하는 버팀목은 바로 단위 테스트

→ 테스트 케이스가 있으면 변경이 두렵지 않기 떄문(없다면 모든 변경이 잠정적인 버그)

테스트 코드가 지저분하면 코드를 변경하는 능력이 떨어짐 ⇒ 코드 구조 개선 능력 떨어짐!

## 깨끗한 테스트 코드

깨끗한 테스트 코드를 만드는 방법 ? 가독성!!

→ 가독성을 높이려면 명료성, 단순성, 풍부한 표현력 필요

테스트 코드는 최소의 표현으로 많은 것을 나타내야 함!

```jsx
public void testGetPageHierarchyAsXml() throws Exception {
  makePages("PageOne", "PageOne.ChildOne", "PageTwo");

  submitRequest("root", "type:pages");

  assertResponseIsXML();
  assertResponseContains(
    "<name>PageOne</name>", "<name>PageTwo</name>", "<name>ChildOne</name>");
}

public void testSymbolicLinksAreNotInXmlPageHierarchy() throws Exception {
  WikiPage page = makePage("PageOne");
  makePages("PageOne.ChildOne", "PageTwo");

  addLinkTo(page, "PageTwo", "SymPage");

  submitRequest("root", "type:pages");

  assertResponseIsXML();
  assertResponseContains(
    "<name>PageOne</name>", "<name>PageTwo</name>", "<name>ChildOne</name>");
  assertResponseDoesNotContain("SymPage");
}

public void testGetDataAsXml() throws Exception {
  makePageWithContent("TestPageOne", "test page");

  submitRequest("TestPageOne", "type:data");

  assertResponseIsXML();
  assertResponseContains("test page", "<Test");
}
```

→ 테스트 구조에 적합

각 테스트는 명확히 세 부분으로 나눠짐

- 테스트 자료 생성
- 테스트 자료 조작
- 조작한 결과 올바른지 확인

→ 진짜 필요한 자료 유형과 함수만 사용!!

### 도메인에 특화된 테스트 언어(DSL)

시스템 조작 API 사용하는 대신 API 위에다 함수와 유틸리티를 구현한 후 그 함수와 유틸리티를 사용 ⇒ 테스트 코드 짜기도 읽기도 쉬워짐!

### 이중 표준

단순하고, 간결하고, 표현력이 풍부해야 하지만, 실제 코드만큼 효율적인 필요는 없다!

→ 테스트 환경에서 돌아가는 코드이기에 실제 환경과 테스트 환경은 요구사항이 판이하게 다름

실제 환경에서는 절대로 안 되지만 테스트 환경에서는 전혀 문제없는 방식 존재 → 이중 표준

- 메모리나 CPU 호율과 관련

    → ex ) `StringBuffer`는 자원이 제한적일 가능성이 낮은 테스트 환경에서만 사용!

- 코드의 깨끗함과는 철저히 무관!

## 테스트 당 assert 하나

Jnit으로 테스트 코드 작성시 함수마다 assert 사용

- 장점 - assert문이 단 하나인 함수는 결론이 하나라서 코드를 히애하기 쉽고 빠름

단일 assert를 사용으로 테스트르르 분리하면 중복 코드 존재 → TEMPLATE METHOD 패턴 사용!

### 테스트 당 개념 하나

테스트 함수마다 한 개념만 테스트하라!

→ 개념을 한 함수로 몰아넣으면 독자가 각 절이 거기에 존재한느 이유와 각 절이 테스트하는 개념 모두 이해 필요

## F.I.R.S.T

깨끗한 테스트는 다음 다섯 가지 규칙

- 빠르게
    - 테스트는 빨리 돌아야 한다.
- 독립적으로
    - 각 테스트는 서로 의존하면 안 된다.
- 반복가능하게
    - 테스트는 어떤 환경에서도 반복 가능해야 한다.
    - 테스트가 돌아기자 않는 환경이 하나라도 존재 시 테스트 실패한 이유 둘러댈 변명 뿐...
- 자가검증하는
    - 테스트는 부울 값으로 결과 도출해야 함
    - 테스트가 스스로 성공과 실패를 가늠하지 않는다면 판단은 주관적이 된다.
- 적시에
    - 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다.

## 결론

테스트 코드는 실제 코드만큼이나 프로젝트 건강에 중요

→ 실제 코드의 유연성, 유지보수성, 재사용성을 보존하고 강화하기 때문

테스트 코드는 지속적으로 깨끗하게 관리하자!

→ 테스트 API를 구현해 도메인 특화 언어를 생성하자!!!